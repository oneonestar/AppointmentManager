\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{lmodern}

\usepackage%
[%
left=2cm,% left margin
right=2cm,% right margin
top=3cm, % top margin
bottom=3cm,% bottom margin
a3paper% other options: a0paper, a1paper, a2paper, a3paper, a4paper, a5paper, a6paper, and many more.
]{geometry}

\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\renewcommand{\And}{\textbf{and}\,}
\newcommand{\Or}{\textbf{or}\,}
\newcommand{\In}{\textbf{in}\,}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}

\author{Star Poon}
\title{COMP2432 Group Project Design Documentation}
\begin{document}
\maketitle
\tableofcontents
\chapter{Foreword}
\section{Introduction}
\section{Scope}
\chapter{Requirement Analysis}
\section{Input commands}
Input formats follow the examples and make no difference and we simply assume all the input formats are correct.
Format checking is not required. 

%---------------------------------
% Command
%---------------------------------
\subsection{Execute the program}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
./amr [users]
./amr alice bob charlie ...
\end{lstlisting}
Username are passed from the command line arguments. Number of users can be determined by the number of arguments. 

\textbf{Requirement:}
\begin{enumerate}
\item Convert the names to the standard format (i.e. first letter capitalized regardless of the input string).
\item Error checking: Number of users are between the range of 3 and 10.
\item Error checking: Duplicated names of users.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add study}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
addStudy -[caller] [datetime] [duration]
addStudy -adam 2015-04-02 18:30 2.5
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}caller{]} & {[}xxx{]} & The username of the caller, should be one of the names from command line arguments. \\
{[}datetime{]} & {[}YYYY-MM-DD hh:mm{]} & \parbox[t]{15cm}{Date and time of the event, YYYY:Year (4 digits), MM:Month (2 digits), DD:Day (2 digits), hh:Hour (2digits) and mm:Minute (2 digits).} \\
{[}duration{]}  & {[}n.n{]} & Duration of the appointment in hours (fixed point of one decimal place).
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: Caller's name should be one of the names from command line arguments.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add assignment}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
addAssignment -[caller] [datetime] [duration]
addAssignment -adam 2015-04-02 18:30 2.5
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}caller{]} & {[}xxx{]} & The username of the caller, should be one of the names from command line arguments. \\
{[}datetime{]} & {[}YYYY-MM-DD hh:mm{]} & \parbox[t]{15cm}{Date and time of the event, YYYY:Year (4 digits), MM:Month (2 digits), DD:Day (2 digits), hh:Hour (2digits) and mm:Minute (2 digits).} \\
{[}duration{]}  & {[}n.n{]} & Duration of the appointment in hours (fixed point of one decimal place).
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: Caller's name should be one of the names from command line arguments.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add project}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
addProject -[caller] [datetime] [duration] [callees]
addProject -adam 2015-04-02 18:30 2.5 alice bob
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}caller{]} & {[}xxx{]} & The username of the caller, should be one of the names from command line arguments. \\
{[}datetime{]} & {[}YYYY-MM-DD hh:mm{]} & \parbox[t]{15cm}{Date and time of the event, YYYY:Year (4 digits), MM:Month (2 digits), DD:Day (2 digits), hh:Hour (2digits) and mm:Minute (2 digits).} \\
{[}duration{]}  & {[}n.n{]} & Duration of the appointment in hours (fixed point of one decimal place). \\
{[}callees{]}  & {[}xxx yyy{]} & The username of the callee(s), should be one of the names from command line arguments.
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: Caller's name should be one of the names from command line arguments.
\item Error checking: Callees' name should be one of the names from command line arguments.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add gathering}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
addGathering -[caller] [datetime] [duration] [callees]
addGathering -adam 2015-04-02 18:30 2.5 alice bob
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}caller{]} & {[}xxx{]} & The username of the caller, should be one of the names from command line arguments. \\
{[}datetime{]} & {[}YYYY-MM-DD hh:mm{]} & \parbox[t]{15cm}{Date and time of the event, YYYY:Year (4 digits), MM:Month (2 digits), DD:Day (2 digits), hh:Hour (2digits) and mm:Minute (2 digits).} \\
{[}duration{]}  & {[}n.n{]} & Duration of the appointment in hours (fixed point of one decimal place). \\
{[}callees{]}  & {[}xxx yyy{]} & The username of the callee(s), should be one of the names from command line arguments.
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: Caller's name should be one of the names from command line arguments.
\item Error checking: Callees' name should be one of the names from command line arguments.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add batch}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
addBatch -[filename]
addBatch -batch001.dat
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}filename{]} & {[}path/filename{]} & Specify a text file that records one or more appointment requests.
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: The file is exist and can be read by the program.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{Add schedule}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
printSchd -[secheduler]
printSchd -fcfs
\end{lstlisting}

\begin{table}[h]
\begin{tabular}{lll}
{[}secheduler{]} & {[}fcfs{]} & First come first served \\
 & {[}prio{]} & Priority \\
 & {[}opti{]} & Optimized
\end{tabular}
\end{table}

\textbf{Requirement:}
\begin{enumerate}
\item Error checking: Caller's name should be one of the names from command line arguments.
\item Error checking: Callee's name should be one of the names from command line arguments.
\end{enumerate}

%---------------------------------
% Command
%---------------------------------
\subsection{End the program}
\begin{lstlisting}[language=bash,basicstyle=\ttfamily,keywordstyle=\bfseries]
endProgram
\end{lstlisting}

\textbf{Requirement:}
\begin{enumerate}
\item Exit the parent and all the child processes.
\end{enumerate}

\section{Special requirements}
\subsection{Priority scheduler}
For the priority algorithm, the priority of the appointments are as follow:
\label{Requirement:Priority}
\begin{enumerate}
\item Assignment
\item Project
\item Study
\item Gathering
\end{enumerate}
A higher priority appointment will displace the already scheduled appointments. The already accepted appointment will be moved to the rejected list once a higher priority appointment displace the original appointment.

\subsection{Modulation}
The system should be divided into different modules logically. System call \texttt{pipe()} and \texttt{fork()} shall be used in the system.
\begin{enumerate}
\item Input Module
\item Scheduling Module
\item Output Module
\end{enumerate}

\subsection{Timeslot}
Every 30 minutes as one time slot. The events will be from 18:00 to 22:00 on weekdays. The system shall support at least two weeks' time. Once part of the time slot is occupied, the whole time slot would be treated as unavailable. The system shall support the overflow situation where appointments are more than the available timeslot.

\chapter{Design and Implementation}
\section{Data Structure}
\subsection{struct Appointment}
The starting time of the appointment is stored in the type \textit{time\_t} which is defined in the standard C library \textless time.h\textgreater. This library provides some time manipulation and conversion functions that are useful in the system design.

The main issue is how should we store the duration of the appointment. The input of the appointment contains the duration of the appointment in the format of n.n hours. We have two choice of storing the ending time:
\begin{lstlisting}
time_t start
float duration
\end{lstlisting}
Or we could use:
\begin{lstlisting}
time_t start
time_t end
\end{lstlisting}

During the insertion, we need to check whether there are conflicts between the existing appointments and the new appointment. We need to determinate if the new appointment is in between the start time and the end time of the existing appointments. It is more convenient to store the ending time instead of the duration so that we can simply use \textit{difftime()}. If we stored the duration instead of the time, we need to do more calculation each time we insert a new appointment. For more details about the conflict checking, please referee to \autoref{Algorithm:conflict}.

\subsection{struct AppointmentList}
We need to store all the appointments that are following the input order. Since the amount of input is unknown, we need to use the dynamic memory allocation to store the data. Considering most of the access are in linear order, \textit{hashtable} is not useful in this situation. We have two choices here, either using the \textit{array} or \textit{linklist}.

For the \texttt{array}:
\begin{itemize}
\item Insert new item: \textbf{Difficult} \\ When the input is too large, we need to allocate a bigger array and copy the original array into it.
\item Insert item at the middle: \textbf{Difficult} \\ We need to move all the items behind the insertion point.
\item Accessing time: \textbf{Fast}
\end{itemize}

For the \texttt{linklist}:
\begin{itemize}
\item Insert new item: \textbf{Easy}
\item Insert item at the middle: \textbf{Easy} \\ Simply modify the two pointers.
\item Accessing time: \textbf{Slow} \\ We need to go through the pointers in order to jump to next item.
\end{itemize}

Since there are a lot of the insertions, linklist performs better in this dimension. We need to insert item at the middle when we doing the scheduling. Although the access of linklist is slower, the gain in insertion should be able to overcome the loss. During the scheduling, we may want to search forward or backward. So we choose a double linked-list to store the appointments.

\subsection{struct User}
We will store the username and a list of accepted and rejected appointments for each user. We will copy the appointment item from the original input list into each users individual list. 
\begin{lstlisting}
char username[MAX_USERNAME];
struct AppointmentList *accepted;
struct AppointmentList *rejected;
\end{lstlisting}
\section{Algorithm}
\subsection{Check appointment conflict}
\label{Algorithm:conflict}
Each time a new appointment is added, we need to check if there is a conflict between the existing appointments and the new appointment. Assuming we are now checking is there are any conflict between $Item_A$ and $Item_B$. There are two cases that the two items are \textit{not} conflict \autoref{Psudo:conflict}.
\begin{algorithm}
\caption{Check conflict between two appointment item}\label{Psudo:conflict}
\begin{algorithmic}
\If {Item$_A$ happened before Item$_B$ \Or Item$_A$ happened after Item$_B$}
\State Conflict happen
\EndIf
\end{algorithmic}
\end{algorithm}
\subsection{First come first served}
This scheduling algorithm will allocate the timeslot to the first appointment. The late requests will be rejected.
\begin{algorithm}
\caption{First come first served (FCFS)}\label{Psudo:FCFS}
\begin{algorithmic}
\State Let $Item_{new}$ be the new appointment
\For {\textbf{each} $List_i$ \In accepted list of caller and callee}
  \If {Conflict between $List_i$ and $Item_{new}$}
    \State Move $Item_{new}$ to rejected list  \Comment In FCFS, late requests will be rejected
    \State \textbf{exit}
  \EndIf
\EndFor
\State Move $Item_{new}$ to accepted list
\end{algorithmic}
\end{algorithm}
\subsection{Priority}
This scheduling algorithm will allocate the timeslot to the appointment which has the highest priority. The priority should follow the requirement documented in \autoref{Requirement:Priority}.
\begin{algorithm}
\caption{Priority}\label{Psudo:Prio}
\begin{algorithmic}
\State Let $Item_{new}$ be the new appointment
\item[]
\LineComment Add all the conflict items into $List_{temp}$
\For {\textbf{each} $Item_i$ \In accepted list of caller and callee}
  \If {Conflict between $Item_i$ and $Item_{new}$}
    \State Add $Item_i$ into $List_{temp}$ 
  \EndIf
\EndFor
\item[]
\LineComment Check if all the conflict items have lower priority than the new item
\For {\textbf{each} $Item_i$ \In $List_{temp}$}
  \If {Priority of $Item_i$\textgreater$Item_{new}$}
    \State Move $Item_{new}$ to rejected list \Comment The existing accepted appointment have higher priority. Reject the new item.
    \State \textbf{exit}
  \EndIf
\EndFor
\item[]
\LineComment All the conflict items have lower priority than the new item. Move the original items to rejected list
\For {\textbf{each} $Item_i$ \In $List_{temp}$}
  \State Move $Item_{i}$ to rejected list
\EndFor
\State Move $Item_{new}$ to accepted list
\end{algorithmic}
\end{algorithm}
\subsection{Optimal}
\begin{algorithm}
\caption{Optimal}\label{Psudo:Opti}
\begin{algorithmic}
\State Call Priority Scheduler
\LineComment Try to reschedule each item in the rejected lists
\For {\textbf{each} $Item_i$ in the rejected list of each user}
  \State $List_{free} \gets$ Free timeslots in the coming 3 day of $List_i$ of the callee
  \For {\textbf{each} $Timeslot_i$ \In $List_{free}$}
    \State Sub $Item_i$ into $Timeslot_i$
    \If {no conflict between the $Item_i$ and the accepted appointments}
      \State $Item_i$.Time = $Timeslot_i$
      \State $Item_i$.Rescheduled = True
      \State Move $Item_i$ to accepted list \Comment Successfully rescheduled an appointment
      \State \textbf{break}
    \EndIf
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}
\end{document}